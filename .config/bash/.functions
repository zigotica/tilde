#!/usr/bin/env bash

#####################################################################################
#                                                                           FUNCTIONS
#####################################################################################

# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$_";
}

# Return n number of history items
function hist() {
  history | tail -"$@";
}

# Return history items matching a grep param
function histg() {
  history | grep "$@";
}

# Bulk rename files/dirs
# use: ren <original> <changed>
# Requires https://github.com/neurobin/rnm
function ren() {
  if [[ $# -eq 2 ]] && [[ `which rnm` != "" ]]; then
    rnm -dp -1 -ss "$1" -rs "/$1/$2/" *
  else
    echo -e "\nPlease call 'ren <original> <changed>' to run this command!\n"
  fi
}

# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh;
	else
		local arg=-sh;
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@";
	else
		du $arg .[^.]* ./*;
	fi;
}

# Create a data URL from a file
function dataurl() {
	local mimeType=$(file -b --mime-type "$1");
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8";
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# show 3 months calendar, current and holiday days colored
# i.e. $ cal
# accepts extra argumens for specific month/year
# i.e. $ cal jan 2022, or $ cal 2022
function cal() {
	if [[ -n "$@" ]]; then
		gcal -s mon --cc-holidays=ES -H '\e[7m\e[34m:\e[0m:\e[7m\e[31m:\e[0m' $@
	else
		gcal -s mon --cc-holidays=ES -H '\e[7m\e[34m:\e[0m:\e[7m\e[31m:\e[0m' .+
	fi;
}

# start quick server from folder
function zerve() {
  python -m http.server 7777
}

# youtube downloader 
# use: ytd video-url
function ytd() {
  youtube-dl -f 'bestvideo+bestaudio/best/best' --merge-output-format mkv $1
}

# only audio
function ytda() {
	youtube-dl -x --audio-format flac $1
}

# ffmpeg quick edits (remove n secs from start or end of file)
# use: trims 100 'input-file.extension' 'output-file.extension' 
function trims(){ ffmpeg -ss $1 -i "$2" -c copy "$3"; }
function trime(){ ffmpeg -ss 0 -t $1 -i "$2" -c copy "$3"; }

# cheatsheet helper using fzf on predefined languages/utils
# then create a tmux pane to show the cheatsheet (using less)
# requires tmux to be already running
# Inspired by ThePrimeagen
# ctrl+h, see .profile
function cheatsh() {
  if [[ ! "$TERM" =~ screen ]]; then
    echo "You need to start a tmux session before running the chetsheet function"
  else
    languages=$(cat ~/.config/bash/fzf-utils/languages.txt)
    utils=$(cat ~/.config/bash/fzf-utils/utils.txt)
    selected=$(echo -e "$languages\n$utils" | fzf)

    read -p "SEEK IN CHEATSHEET: " what

    if echo "$languages" | grep -qs $selected; then
      tmux splitw -h bash -c "curl cht.sh/$selected/$(echo "$what" | tr " " "+") | less -R"
    else
      tmux splitw -h bash -c "curl cht.sh/$selected~$what | less -R"
    fi
  fi
}

# https://github.com/nvm-sh/nvm#automatically-call-nvm-use
# use node version defined in .nvmrc file automatically upon cd into a project,
# if that project folder includes a .nvmrc file,
# otherwise, use default version defined in nvm ls
cdnvm(){
    cd "$@";
    nvm_path=$(nvm_find_up .nvmrc | tr -d '\n')

    # If there are no .nvmrc file do nothing (use default, so you better have one)
    # There is a .nvmrc file:
    if [[ $nvm_path = *[^[:space:]]* && -s $nvm_path/.nvmrc && -r $nvm_path/.nvmrc ]]; then
      declare nvm_version
      nvm_version=$(<"$nvm_path"/.nvmrc)

      # Add the `v` suffix if it does not exists in the .nvmrc file
      if [[ $nvm_version != v* ]]; then
        nvm_version="v""$nvm_version"
      fi

      # If it is not already installed, install it
      required_version_from_nvm_ls=$(nvm ls --no-colors "$nvm_version" | tail -1 | tr -d '\->*' | tr -d '[:space:]')
      if [[ "$required_version_from_nvm_ls" == "N/A" ]]; then
        nvm install "$nvm_version";
      fi

      nvm_current=$(nvm current)
      if [[ "$nvm_current" != "$nvm_version" ]]; then
        nvm use "$nvm_version";
      fi
    fi
}
alias cd='cdnvm' # alias after the function, just in case

# GoTo: find and move to favourite folder using fzf
# then create a tmux session there (starts tmux if not running)
# Inspired by ThePrimeagen
# ctrl+g, see .profile
function gt() {
  targets=$(cat ~/.config/bash/fzf-utils/dirs-personal.txt  ~/.config/bash/fzf-utils/dirs-work.txt | tr "\n" " " | sed "s|~|$HOME|g")
  selected=$(find $targets -mindepth 1 -maxdepth 1 -type d | fzf)
  foldername=$(basename "$selected" | tr . _)

  if ! tmux has-session -t "$foldername" 2> /dev/null; then
    tmux new-session -s "$foldername" -c "$selected" -d
    tmux send-keys -t "$foldername" "cd $selected" C-m
    if [[ ! "$TERM" =~ screen ]]; then
      tmux attach -t "$foldername"
    else
      tmux switch-client -t "$foldername"
    fi
  else
    tmux attach -t "$foldername"
  fi
}

# Add current folder (in ~ format) to fzf personal/work favourites
# These can then be used by the gt function above
# ctrl+f, see .profile
function f() {
  folder=$(echo $PWD | sed "s|$HOME|~|g")

  # Save in work list by default
  list="Work"
  file="$HOME/.config/bash/fzf-utils/dirs-work.txt"
  workfolder="~/Documents/work"
  projectsfolder="~/Documents/projectes"

  # set personal file as target if not inside work/projectes hierarchy
  if [[ $folder != *"$workfolder"* ]] && [[ $folder != *"$projectsfolder"* ]]; then
    file="$HOME/.config/bash/fzf-utils/dirs-personal.txt"
    list="Personal"
  fi

  # If folder is not listed in file, append it, else remove it
  if ! grep -xqF "$folder" "$file"; then
    echo "$folder" >> $file
    echo "Appended $folder to $list GoTo fzf list"
  else
    grep -xFv "$folder" $file > tmp_$$ && mv -f tmp_$$ $file
    echo "Removed $folder from $list GoTo fzf list"
  fi
}

# setup tmux session for development
# will create 1 main pane for coding, and two bottom panes for terminal
# requires being called from inside a tmux window/session
# optional argument:
# -l layout (by default vh meaning 1 main on top, 2 on bottom)
#    can also be any combination of v / h
#    for instance:
#    -l hhh will create 3 horizontal splits, while 
#    -l hvvv will create one horizontal then 3 vertical
function dev() {
  if [[ ! "$TERM" =~ screen ]]; then
    echo "You need to start a tmux session before running this function"
  else
    layout="vh"

    # get optional layout from -l argument
    while getopts 'l:' opt
    do
      case $opt in
        l) local layout="$OPTARG"; ;;
      esac
    done

    # create splits
    vh=$(echo $layout | tr -cd 'vh')
    for (( i=0; i<${#vh}; i++ )); do
      what="${vh:$i:1}"
      if [[ $i = 0 ]]; then
        # main split 75%
        tmux splitw -$what -p 25
      else
        tmux splitw -$what
      fi
    done

    # run vim in 1st split
    tmux selectp -t 1 
    tmux send-keys "v" C-m
    # run cd . in the other splits so they can get the cdnvm
    tmux selectp -t 2
    tmux send-keys "cd ." C-m
    tmux selectp -t 3
    tmux send-keys "cd ." C-m
  fi
}
