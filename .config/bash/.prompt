#!/usr/bin/env bash
#####################################################################################
#                                                                          CONNECTION
#####################################################################################
function is_ssh() {
  if [[ -n $SSH_CONNECTION ]]; then
    echo -ne "${Red} "
  else
    echo ""
  fi

}

function is_tmux() {
  if [ "$TERM" = "screen-256color" ] && [ -n "$TMUX" ]; then
    echo -ne " 舘"
  else
    echo ""
  fi
}

######################################################################################
#                                                                      COLORS & ICONS
#####################################################################################
# you might need to install icon fonts and make them available to terminal
# https://github.com/gabrielelana/awesome-terminal-fonts/wiki/OS-X
: ${branch_icon:=''}
: ${clean_icon:='✔'}
: ${merge_icon:=''}
: ${develop_icon:=''}
: ${ahead_icon:='⇡'}
: ${behind_icon:='⇣'}
: ${staged_icon:='✚'}
: ${untracked_icon:='✘'}
: ${alert_icon:=''}

Red="$(tput setaf 1)"
Green="$(tput setaf 2)"
Yellow="$(tput setaf 3)"
Orange="$(tput setaf 130)"
Blue="$(tput setaf 4)"
Pink="$(tput setaf 5)"
RESET="$(tput sgr0)"

#####################################################################################
#                                                                        OS DETECTION
#####################################################################################
function os_detection() {
  os=""
  krnl=""
  krnl="$(uname -s)"

  if [ "$krnl" == "Darwin" ]; then
    os="macos"
  elif [ "$krnl" == "Linux" ]; then
    if [ -e "/etc/os-release" ]; then
      os="$(. /etc/os-release; printf "%s" "$ID")"
    fi
  fi

  if [[ $os == "macos" ]]; then
     echo -ne "${White}"
  elif [[ $os == "arch" ]]; then
    echo -ne "${Blue} "
  elif [[ $os == "manjaro" ]]; then
    echo -ne "${Green} "
  elif [[ $os == "raspbian" ]]; then
    echo -ne "${Pink}"
  fi
}

#####################################################################################
#                                                                              PROMPT
#####################################################################################

# https://stackoverflow.com/a/24067243
function version_gt() {
  test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1";
}

function strip_number() {
  echo $1 | xargs
}

function node_v() {
  if hash node 2>/dev/null; then
    nv=$(node -v | tr -d '[v]')
  fi

  # do we have a .nvmrc to compare against
  if [ -r ".nvmrc" ] && [ -f ".nvmrc" ]; then
    expected="$(cat .nvmrc | tr -d '[:space:]' | tr -d '[v]')"
    if version_gt $expected $nv; then
      [ "$nv" != "" ] && echo -ne "${Red} ${nv}${alert_icon} "
    else
      [ "$nv" != "" ] && echo -ne "${Green} ${nv}"
    fi
  else
    [ "$nv" != "" ] && echo -ne "${Green} ${nv}"
  fi
}

function dot_dirty() {
  local repo_status=$(dot status 2>&1 | tail -n1)
  if [[ $repo_status != *"nothing to commit"* ]]; then
    echo " ${Red}*"
  else
    echo " ${Green}${clean_icon}"
  fi
}

function git_dirty() {
  local repo_status=$(git status 2>&1 | tail -n1)
  [[ $repo_status != "nothing to commit, working tree clean" ]] && echo " ${Red}*"
}

function dot_branch() {
  # show either the branch name or the detached HEAD
  _branch="$(dot symbolic-ref --short HEAD)"
  if [[ $_branch != "" ]]; then
    echo -ne "${Yellow}${branch_icon} $_branch"
  else
    hd="$(dot rev-parse --short HEAD | head -n 1)"
    echo -ne "${Red}${branch_icon} detached HEAD $hd"
  fi
}

function git_branch() {
  # show either the branch name or the detached HEAD
  _branch="$(git symbolic-ref --short HEAD)"
  if [[ $_branch != "" ]]; then
    echo -ne "${Yellow} ${branch_icon} $_branch"
  else
    hd="$(git rev-parse --short HEAD | head -n 1)"
    echo -ne "${Red} ${branch_icon} detached HEAD $hd"
  fi
}

function dot_staged() {
  count="$(dot diff --cached --name-only | wc -l)"
  count=`strip_number $count`
  if [[ $count != "0" ]]; then
    echo -ne "${Green} ${staged_icon}${count}"
  else
    echo ""
  fi
}

function staged() {
  count="$(git diff --cached --name-only | wc -l)"
  count=`strip_number $count`
  if [[ $count != "0" ]]; then
    echo -ne "${Green} ${staged_icon}${count}"
  else
    echo ""
  fi
}

function dot_unstaged() {
  count="$(dot diff --name-status | wc -l)"
  count=`strip_number $count`
  if [[ $count != "0" ]]; then
    echo -ne "${Red} ?${count}"
  else
    echo ""
  fi
}

function unstaged() {
  count="$(git diff --name-status | wc -l)"
  count=`strip_number $count`
  if [[ $count != "0" ]]; then
    echo -ne "${Red} ?${count}"
  else
    echo ""
  fi
}

function untracked() {
  count="$(git ls-files --others --exclude-standard | wc -l)"`echo $count | sed 's/ *$//g'`
  count=`strip_number $count`
  if [[ $count != "0" ]]; then
    echo -ne "${Red} ${untracked_icon}${count}"
  else
    echo ""
  fi
}

function reference_branch_count(){
  # yes, for simplicity we assume our remote is 'origin'
  echo strip_number $(git rev-parse --branches=refs/remotes --symbolic-full-name --all | grep origin/$1 | wc -l)
}

function commits_diff_count(){
  # yes, for simplicity we assume our remote is 'origin'
  echo strip_number $(git rev-list $1..$2 --count)
}

function behindahead() {
  # current branch name
  br="$(git rev-parse --abbrev-ref HEAD)"
  rbr=""

  if [[ $br != "HEAD" ]]; then
    # check if remote 'origin' exists
    # yes, for simplicity we assume our remote is 'origin'
    r="$(git remote get-url origin 2>&1 | tail -n1)"
    if [[ $r != "fatal: No such remote 'origin'" ]]; then
      # we want two types of behind/ahead references: 
      # 1. behind count respect reference branch (remote develop/main/master):
      #    - develop's reference to be main/master, 
      #    - feature branch's reference to be develop/main/master
      # 2. behind/ahead count respect same branch in remote

      # check if branch in remote exists (count the refs/remotes)
      branch_count=`$(reference_branch_count $br)`
      dev_count=`$(reference_branch_count "develop")`
      main_count=`$(reference_branch_count "main")`
      master_count=`$(reference_branch_count "master")`

      if [[ $br != "main" ]] && [[ $br != "master" ]]; then
        # echo "\nnot main nor master, can be develop or feature branch"
        if  [[ $br != "develop" ]] && [[ $dev_count != "0" ]]; then
            # echo "\nfeature branch w/ remote develop"
            rbr="develop"
        else
          # echo "\ndevelop branch or feature branch w/o remote develop"
          if [[ $main_count != "0" ]]; then
            # echo "\nw/ remote main"
            rbr="main"
          else
            if [[ $master_count != "0" ]]; then
              # echo "\nw/ remote master"
              rbr="master"
            fi
          fi
        fi
      fi

      # echo "\nif current branch not develop/main/master and any of these exist in origin, count behind commits"
      if [[ $rbr != "" ]]; then
        # echo "\ncount behind origin/${rbr}"
        bhr=`$(commits_diff_count "$br" "origin/$rbr")`
        # echo "\nshow counter behind origin/${rbr} if > 0 bhr:${bhr}"
        [[ $bhr != "0" ]] && echo -ne "${Red} ${develop_icon} ${behind_icon}${bhr} "
      fi

      # echo "\nif origin/${br} exists we can count behind/ahead commits"
      if [[ $branch_count != "0" ]]; then
        # echo "\nremote ${br} branch exists, use it as a reference"
        upstream="origin/${br}"
        bh=`$(commits_diff_count "$br" "$upstream")`
        ah=`$(commits_diff_count "$upstream" "$br")`
        # echo "\n${br} is bh:${bh} and ah:${ah} upstream ${upstream}"


        if [[ $bh != "0" ]] && [[ $ah == "0" ]]; then
          # echo "\nbranch ${br} is behind origin ${upstream}"
          echo -ne "${Orange} ${merge_icon}${behind_icon}${bh}"
        fi
        if [[ $bh == "0" ]] && [[ $ah != "0" ]]; then
          # echo "\nbranch ${br} is ahead origin ${upstream}"
          echo -ne "${Green} ${merge_icon}${ahead_icon}${ah}"
        fi
        if [[ $bh != "0" ]] && [[ $ah != "0" ]]; then
          # echo "\nbranch ${br} is behind and ahead origin ${upstream}"
          echo -ne "${Orange} ${merge_icon}${behind_icon}${bh}${Green} ${ahead_icon}${ah}"
        fi
        if [[ $bh == "0" ]] && [[ $ah == "0" ]]; then
          # echo "\nbranch ${br} is synced with origin ${upstream}"
          echo -ne "${Green} ${clean_icon}"
        fi
      fi

    fi
  fi
}

function real_time_prompt() {
  PS1="\[\033]0;\W\007\]";

  if [[ "$HOME" == "$PWD" ]] || [[ "$PWD" == "$HOME/.config/"* ]]; then
    dots=true
    PS1+="\n\n\[$(os_detection)\] \u@\h\[$(is_tmux)\] \w "
    PS1+="\n\[$(dot_branch)\]\[$(dot_dirty)\]\[$(dot_staged)\]\[$(dot_unstaged)\]"
  else
    PS1+="\n\n\[$(os_detection)\] \u@\h\[$(is_tmux)\] \[${Blue}\]\w "
  fi

  # modify prompt adding development info if we are in a git repo folder
  if `git status &> /dev/null`; then
    PS1+="\n\[$(node_v)\]"
    PS1+="\[$(git_branch)\]\[$(git_dirty)\]\[$(staged)\]\[$(unstaged)\]\[$(untracked)\]"

    # show behind/ahead info if branches count>0 (maybe we just init'ed git repo)
    bc="$(git branch --list | wc -l | xargs)"
    if [[ $bc != "0" ]]; then
      PS1+="\[$(behindahead)\]"
    fi
  fi

  PS1+="\n\[$(is_ssh)\]\[${RESET}\] "

  export PS1
}
PROMPT_COMMAND='real_time_prompt'
