#!/usr/bin/env bash

# git interactive checkout wrapper
# 
# If argument is missing, select branch, tag or commit using fzf
# fzf provides the fzf list in a simple format:
#   branch/tag/commit (space) [branch] or [tag] or commit message
#   if a worktree is currently using the branch, mark as [worktree]
# fzf will preview diff of that hash (any of the 3 types above)) with its previous
# (git diff --color HASH~ HASH)
#
# If the target branch is currently checked out in any worktree, move there
# Otherwise, try to checkout a branch, tag or commit (in that likelihood order)
# Finally, if nothing found, create a branch with that name
#
# Requires: $SPLIT_DELIMITER
# 
# use case: gc (launches fzf to choose from branches, tags or commits)
# use case: gc dev (moves to worktree currently using dev branch, or checkout dev branch on current worktree)

separator=$(echo $SPLIT_DELIMITER)

is_worktree() {
  # remove color info before match test
  # https://stackoverflow.com/a/30938702
  raw=$(echo "[$1]" | sed -r "s/\x1B\[(([0-9]{1,2})?(;)?([0-9]{1,2})?)?[m,K,H,f,J]//g")
  wt=$(git-worktree -l | awk -v q=$raw '$3 == q { print "[worktree]" }')
  if [[ $wt != "" ]]; then
    echo -ne "\e[31m$wt\e[0m ";
  fi
}
export -f is_worktree;

if [[ -z $@ ]]; then
  target=$({ git for-each-ref refs/heads/ --format='%(color:green)%(refname:short)%(color:reset) [branch]' --color=always; git for-each-ref refs/tags/  --format='%(color:blue)%(refname:short)%(color:reset) [tag]' --color=always; git log --oneline --abbrev-commit --branches=*  --color=always; } | awk '{ if($2=="[branch]" || $2=="[tag]") { system("bash -c '\''is_worktree "$1"'\''"); print $1 " " $2; } else { print $0 } }' | sed -e 's/^[ \t]*//' | fzf --ansi --print-query --preview="echo {} | awk '{ print \"diff --color \" \$1\"~ \" \$1 }' | xargs git" | sed "s/ /$separator/g")
  if [[ $target != "" ]]; then
    # if selected from fzf list
    ss=($(split-string $target "$separator"))
    declare -a ss
    query=${ss[0]}
    len=${#ss[@]}
    last=${ss[ len - 1 ]}
    [[ ${ss[0]} == "[worktree]" ]] && query=${ss[1]}
    if [[ $last != "[branch]" ]] && [[ $last != "[tag]" ]]; then
      last="commit"
    fi
  else
    # if escaping fzf, exit
    exit 0;
  fi
else
  query=$1
fi

# Checks if the target branch is currently checked out in any worktree
wtpath=$(git-worktree -l | awk -v q=$query '$3 == "["q"]" {print $1}')
if [[ $wtpath != "" ]]; then
  if [[ "$wtpath" == *"$separator"* ]]; then
    ss=($(split-string $wtpath $separator))
    declare -a ss
    linkedwt=${ss[1]}
    git-worktree -m $linkedwt
  else
    git-worktree -m
  fi
else
  # no worktree using the same branch/tag/detached commit
  # detect if a branch / tag / commit exist
  # otherwise create a branch with that name
  if [[ -z $last ]]; then
    # use the value passed manually
    # try to find the best match, by likelihood order (branch > tag > commit)
    git checkout $(git show-ref --verify --quiet refs/heads/"$query" || git show-ref --verify --quiet refs/tags/"$query" || git cat-file -e $query^{commit} || echo "-b") $query
  elif [[ $type == "[branch]" ]]; then
    git checkout $(git show-ref --verify --quiet refs/heads/"$query" || echo "-b") $query
  elif [[ $type == "[tag]" ]]; then
    git checkout $(git show-ref --verify --quiet refs/tags/"$query" || echo "-b") $query
  else
    git checkout $(git cat-file -e $query^{commit} || echo "-b") $query
  fi
fi

